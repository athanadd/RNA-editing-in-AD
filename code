The .fastq files with the following SRA accession numbers were downloaded:
SRR609422
SRR609423
SRR609424
SRR609425
SRR609426
SRR609427
SRR609428
SRR609429
SRR609430

The files were analysed using FastQC (http://www.bioinformatics.babraham.ac.uk/projects/fastqc/) without any extra options.

The following trimmings were performed using trim_galore! (http://www.bioinformatics.babraham.ac.uk/projects/trim_galore/):

First trimming: Illumina standard

Second trimming:	
trim_galore --fastqc -o output_directory -a2 TGGTATCAACGCAGAGTACTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT -a TGGTATCAACGCAGAGTACTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT --paired file_1.fastq.gz file_2.fastq.gz

Third trimming:
trim_galore --fastqc -o output_directory -a2 TGGTATCAACGCAGAGTACATGGGATGGCACATGCAGCGCAAGTAGGTCT -a TGGTATCAACGCAGAGTACATGGGATGGCACATGCAGCGCAAGTAGGTCT --paired file_1.fastq.gz file_2.fastq.gz

Fourth trimming(for SRR609422,SRR609423,SRR609425 only):
trim_galore --fastqc -o output_directory -a2 TGGTATCAACGCAGAGTCCGGTAATCGCATAAAACTTAAAACTTTACAGT -a TGGTATCAACGCAGAGTCCGGTAATCGCATAAAACTTAAAACTTTACAGT --paired file_1.fastq.gz file_2.fastq.gz

Fifth trimming(for all):	
trim_galore --fastqc -o output_directory -a2 TGGTATCAACGCAGAGTACATGGGCAACTTCTTAGAGGGACAAGTGGCGT -a TGGTATCAACGCAGAGTACATGGGCAACTTCTTAGAGGGACAAGTGGCGT --trim1 --clip_R1 8 --clip_R2 8 --three_prime_clip_R1 3 --three_prime_clip_R2 3 --paired file_1.fastq.gz file_2.fastq.gz

The sequences of the same phenotype were merged in one file using the cat command:
cat SRR609422-26.fastq.gz > AD_phenotype.fastq.gz
cat SRR609427-30.fastq.gz > Control_phenotype.fastq.gz

The alignment was then performed using tophat2 (https://ccb.jhu.edu/software/tophat/index.shtml):

tophat genes.gtf -g 1 --no-novel-indels --no-coverage-search --mate-inner-dist=-46 --mate-std-dev=40 --transcriptome-index=hg38/transcriptome_data --read-mismatches 3 --read-edit-dist 3 --read-realign-edit-dist 0 -a 12 -m 1 -o output_directory hg38/Bowtie2Index/genome input_file_1 input_file_2

The bam files were sorted and indexed using samtools (http://samtools.sourceforge.net/):

samtools sort -o sorted_file.bam accepted_hits.bam
samtools index sorted_file.bam

A Blat Correction analysis was performed using the original script provided from the REDItools website (http://reditools.sourceforge.net):

python REDItoolBlatCorrection.py -i input_bam_file -o output_directory -V -f reference_fasta_file -F reference_2bit_file

The main analysis was performed by REDItool Denovo, a script of the REDItools suite:

python REDItoolDenovo.py -i input_bam_file -o output_directory snps_file -p -f reference_fasta_file -e -l -u -B blat_correction_directory -W splice_sites

The snps and splice_sites files were prepared according to the official REDItools documentation.

The output table with the significant sites was converted in order to be processed by ANNOVAR using the following R script:

R --vanilla --quiet <<RSCRIPT
.libPaths("path_to_library")
library(dplyr)


  reditools = read.table(skip = 1, "table_sig_from_REDItools")
  Alt_base = sapply(as.character(reditools[,11]), function(x){
    unlist(strsplit(x, split = ""))[[2]]
    })
  reditools%>%
    (function(x){
      cbind(x[,1], x[,2], x[,2], x[,3], Alt_base, x[,4:ncol(x)])
      })%>%
    (function(y){
      write.table(y, file = "converted_file" , 
                  row.names = FALSE, col.names = FALSE,quote = FALSE)
    })
RSCRIPT

The converted file is used as an input to ANNOVAR (http://annovar.openbioinformatics.org/en/latest/):

ANNOVAR/table_annovar.pl converted_file annovar_files/humandb/hg38 -buildver hg38 -remove -protocol refGene,snp144 -operation g,f -nastring . -csvout -out annotated_file

The strand correction takes place using a custom R function that detects the position of each gene from a reference file and adds this information to the position of the editing event. The reference file is obtained from UCSC and is Homo_sapiens.GRCh38.83.csv for human datasets.

#To use the script, copy and paste the whole folder to a new directory.
#Place the output, annotated by ANNOVAR files in a subdirectory called "annotated",
#place the REDItools converted files in a subdirectory called "converted".


#Function to add the strand information. The output files will be placed
#in a subdirectory called "with_strand". File names will be preserved.
add.strand <- function(species) {
        library(dplyr)
        
        #Get the full paths of the input files
        annotated = list.files("./annotated", full.names = T)
        converted = list.files("./converted", full.names = T)
        
        #Set the variables of the annotation files according to the species
        if (species == "mouse") {
                RG = read.csv("./required_files/mouse/Mus_musculus_ensembl_dataset.csv")
                RG = RG[!duplicated(RG$gene_name), ]
        }
        else if (species == "human") {
                RG = read.csv("./required_files/human/Homo_sapiens.GRCh38.83.csv")
                RG = RG[!duplicated(RG$gene_name),]
        }
        
        #Create the ouputs folder
        dir.create("./with_strand")
        
        #Start the loop for each file
        for (y in seq_along(annotated)) {
                TA = read.csv(annotated[y])
                ind1 = nrow(TA)
                strand_vector = c()
                
                for (i in seq(ind1)) {
                        # if the position is located in intergenic, upstream or downstream region,
                        # then it is assigned directly with ".", because strand cannot be defined
                        
                        if (TA[i, "Func.refGene"] %in% c("intergenic",
                                                         "upstream",
                                                         "downstream")) {
                                print("no_strand")
                                strand_vector = c(strand_vector, ".")
                        }
                        else {
                                pos = unlist(strsplit(as.character(TA[i, "Gene.refGene"]), split = ","))
                                
                                # one gene name for this position
                                if (length(pos) == 1) {
                                        if (length(which(RG$gene_name == pos)) == 1) {
                                                ind2 = which(RG$gene_name == pos)
                                                strand_vector = c(
                                                        strand_vector,
                                                        as.character(RG$strand[ind2])
                                                )
                                        }
                                        else {
                                                # "missing" if the gene name is not matched
                                                strand_vector = c(strand_vector,
                                                                  "missing")
                                        }
                                }
                                else {
                                        # two gene names in this position
                                        if (length(which(RG$gene_name == pos[1])) ==
                                            1) {
                                                ind2 = which(RG$gene_name == pos[1])
                                                strand_vector = c(
                                                        strand_vector,
                                                        as.character(RG$strand[ind2])
                                                )
                                        }
                                        else if (length(which(RG$gene_name == pos[2])) ==
                                                 1) {
                                                ind2 = which(RG$gene_name == pos[2])
                                                strand_vector = c(
                                                        strand_vector,
                                                        as.character(RG$strand[ind2])
                                                )
                                        }
                                        else {
                                                strand_vector = c(strand_vector,
                                                                  "missing")
                                        }
                                }
                        }
                }
                
                # the strand information has been gathered in the strand_vector
                new_TA_1 = TA[, which(colnames(TA) == "Chr"):which(colnames(TA) ==
                                                                           "Alt")]
                new_TA_1 = mutate(new_TA_1, strand = strand_vector)
                new_TA_2 = cbind(new_TA_1, TA[, which(colnames(TA) == "Func.refGene"):ncol(TA)])
                output = list.files("./converted")[y]
                output = gsub("converted_", "", output)
                output = paste0("./with_strand/", output, ".csv")
                write.csv(new_TA_2, file = output)
        }
}

#Choose between "human" or "mouse" for species
#and run this function!
add.strand("human")

#Function to filter the RNA editing positions and keep edititng events
#that appear on the correct strand. The function also splits the tables
#according to the enzyme (ADAR, APOBEC).
#The output files will be placed in a subdirectory called "final_files".
### WARNING - The function does NOT remove SNPs, they should already be
#absent by providing them as input to REDItools.
filter.files <- function(){
        
        library(xlsx)
        library(dplyr)
        
        #Get the full paths of the input files
        converted = list.files("./converted", full.names = T)
        with.strand = list.files("./with_strand/", full.names = T)
        
        #Create the ouputs folders
        dir.create("./final_files/ADAR_all_positions/tables", recursive = T)
        dir.create("./final_files/APOBEC_all_positions/tables", recursive = T)
        dir.create("./final_files/ADAR_all_positions/xlsx", recursive = T)
        dir.create("./final_files/APOBEC_all_positions/xlsx", recursive = T)
        
        #Start the loop for each file
        for (y in seq_along(converted)) {
                
                output = list.files("./converted")[y]
                output = gsub("converted_", "", output)
                table_annovar = read.csv(with.strand[y])
                index=read.table(converted[y])
                data1 = table_annovar%>%
                        mutate(Read_depth = index[,7])%>%
                        mutate(Quality_score = index[,8])%>%
                        mutate(Variant_allele_frequency = index[,14])%>%
                        mutate(P_value = index[,15])
                
                #For APOBEC
                
                data2 = data1 %>%
                        (function(x){
                                index1 = c(which(data1$Ref == "C" & data1$Alt == "T" & data1$strand %in% c(".","+","missing")), 
                                           which(data1$Ref == "G" & data1$Alt == "A" & data1$strand %in% c(".","-","missing")))
                                x[index1,]
                        }) %>%
                        (function(x){x})
                
                data2 <- data2[which(data2$snp144 == "."), ]
                
                write.table(row.names = FALSE,data2,file=paste0("./final_files/APOBEC_all_positions/tables/APOBEC.",output))
                write.xlsx(row.names = FALSE,data2,file=paste0("./final_files/APOBEC_all_positions/xlsx/APOBEC.",output,".xlsx"))
                
                #For ADAR
                
                data2 = data1%>%
                        (function(x){
                                index1 = c(which(data1$Ref == "A" & data1$Alt == "G" & data1$strand %in% c(".","+","missing")), 
                                           which(data1$Ref == "T" & data1$Alt == "C" & data1$strand %in% c(".","-","missing")))
                                x[index1,]
                        }) %>%
                        (function(x){x})
                data2 <- data2[which(data2$snp144 == "."), ]
                
                write.table(row.names = FALSE,data2,file=paste0("./final_files/ADAR_all_positions/tables/ADAR.",output))
                write.xlsx(row.names = FALSE,data2,file=paste0("./final_files/ADAR_all_positions/xlsx/ADAR.",output,".xlsx"))
        }
}

#Just run the function
filter.files()

For the differential gene expression analysis(performed entirely in R):

For the differential expression analysis the workflow described at the Bioconductor website was followed. The comments can also be found at the same workflow (some of them are copied below to facilitate reading). It can be found at this link http://www.bioconductor.org/help/workflows/rnaseqGene/


Create the table that contains info about the samples and load it.
sample.table <- read.csv("sample_table.csv", sep = ";", row.names = 1)

Using the Run column in the sample table, we construct the full paths to the files we want to perform the counting operation on

filenames <- file.path ("G:", "satoh_sorted_bam_files",paste0( "sorted_", sample.table$Run, ".bam"))

We indicate in Bioconductor that these files are BAM files using the BamFileList function from the Rsamtools package:
library("Rsamtools")
bamfiles <- BamFileList(filenames, yieldSize=2000000)

Change the names of the bamfiles because they should not be all the same:
names(bamfiles) <- sample.table$Run

Next, we need to read in the gene model that will be used for counting reads/fragments. We will read the gene model from UCSC GTF file, using makeTxDbFromGFF from the GenomicFeatures package:
library("GenomicFeatures")

We indicate that none of our sequences (chromosomes) are circular using a 0-length character vector:
genesfile <- file.path ( "C:", "R_wd", "required_files", "known_genes", "hg38_genes", "Homo_sapiens.GRCh38.84.gtf")
txdb <- makeTxDbFromGFF (genesfile, format="gtf", circ_seqs=character())

The following line produces a GRangesList of all the exons grouped by gene:
ebg <- exonsBy(txdb, by="gene")

Change the chromosomes names to match the gtf file:
first, get the names of the chromosomes:

library("GenomeInfoDb")
chrUCSC <- extractSeqlevels(species="Homo_sapiens", style="UCSC")
chrENSEMBL <- extractSeqlevels(species="Homo_sapiens", style="Ensembl")

Create a vector with the "from-to" names:

newnames <- chrUCSC #To
names(newnames) <- chrENSEMBL #From

Rename:
ebg2 <- renameSeqlevels(ebg,newnames)

The function summarizeOverlaps from the GenomicAlignments package will do the counting. This produces a SummarizedExperiment object that contains a variety of information about the experiment:

library("GenomicAlignments")

se <- summarizeOverlaps(features=ebg2, reads=bamfiles,
                        mode="Union",
                        singleEnd=FALSE,
                        fragments=FALSE,
                        ignore.strand=TRUE )


The colData slot, so far empty, should contain all the metadata.
Because we used a column of sampleTable to produce the bamfiles vector, we know the columns of se are in the same order as the rows of sampleTable. We can assign the sampleTable as the colData of the summarized experiment, by converting it into a DataFrame and using the assignment function:
colData(se) <- DataFrame(sample.table)

Note: it is prefered in R that the first level of a factor be the reference level (e.g. control, or untreated samples), so we can relevel the dex factor:

se$Phenotype <- relevel(se$Phenotype, "normal")

Once we have our fully annotated SummarizedExperiment object, we can construct a DESeqDataSet object from it that will then form the starting point of the analysis. We add an appropriate design for the analysis:

library("DESeq2")
dds <- DESeqDataSet(se, design = ~ Phenotype)

We remove rows of the DESeqDataSet that have no counts, or only a single count across all samples:

dds <- dds[ rowSums(counts(dds)) > 1, ]

We perform the rlog transformation:

rld <- rlog(dds)

We can run the differential expression pipeline on the raw counts with a single call to the function DESeq:

dds2 <- DESeq(dds)

Calling results without any arguments will extract the estimated log2 fold changes and p values for the last variable in the design formula:

res <- results(dds2)

We keep results with a p-value lower than 0.05:

res.sig <- res[!is.na(res$padj),]
res.sig <- res.sig[res.sig$padj < 0.05, ]

Use Ensembl ids to add gene symbols
library("AnnotationDbi")  #Base package
library("org.Hs.eg.db")  #Human

res.sig$SYMBOL <- mapIds(org.Hs.eg.db,
                          keys=row.names(res.sig),
                          column="SYMBOL",
                          keytype="ENSEMBL",
                          multiVals="first")


res$SYMBOL <- mapIds(org.Hs.eg.db,
                                keys=row.names(res),
                                column="SYMBOL",
                                keytype="ENSEMBL",
                                multiVals="first")

Export the results to be used at the pathway analysis:

dir.create("outputs")
library("xlsx")
write.xlsx(res.sig, "outputs/sig.results.GE.xlsx")
write.table(res, "outputs/results.group1")

Differential RNA editing analysis (performed entirely in R):

#Place the final files from the editing meta analysis in the folder called "input_files"

#Load the files
adar.ad <- read.table("input_files/ADAR.AD", header = T)
adar.normal <- read.table("input_files/ADAR.normal", header = T)
apobec.ad <- read.table("input_files/APOBEC.AD", header = T)
apobec.normal <- read.table("input_files/APOBEC.normal", header = T)

#Function to remove the first column and the snp144 column and filter by editing frequency
#threshold is the minimum frequency to keep
#freq.col is the column containing the frequencies
#rm.col is a numerical vector containing the columns to remove
filter.frequency <- function(table, min.freq = 0.00, max.freq = 0.9, freq.col = 16, rm.col = c(1,13)){
        table <- table[which(table[,freq.col] >= min.freq),]
        table <- table[which(table[,freq.col] <= max.freq),]
        table <- table[,-rm.col]
        row.names(table) <- seq_len(nrow(table))
        table
}

adar.ad <- filter.frequency(adar.ad)
adar.normal <- filter.frequency(adar.normal)
apobec.ad <- filter.frequency(apobec.ad)
apobec.normal <- filter.frequency(apobec.normal)

#Function to generate a table that shows the distribution of the rna editing
#positions
editing.dist <- function(table){
        table[,"Func.refGene"] <- as.character(table[,"Func.refGene"])
        types <- unique(table[, "Func.refGene"])
        new.table <- as.data.frame(matrix(nrow = 1, ncol = length(types)))
        names(new.table) <- types
        for (i in seq_along(types)){
                rows <- nrow(table[which(table[,"Func.refGene"] == types[i]), ])
                new.table[1, types[i]] <- rows
        }
        new.table
        
}

#Manually make the barplot of the distribution using the function above

#Function to:
#1. remove unwanted columns
#2. rename "Start" and "End" to "Position"
reorganize <- function(table){
        new.table <- table[,-c(3,12,13,15)]
        names(new.table)[2] <- "Position"
        new.table
}

adar.ad <- reorganize(adar.ad)
adar.normal <- reorganize(adar.normal)
apobec.ad <- reorganize(apobec.ad)
apobec.normal <- reorganize(apobec.normal)

#Function to select common and unique sites
#the prepositions "common" "normal" and "ad" will automaticaly be added
# The function adds a final column with a logical value that tests whether
#the two frequences differ for a certain percentage.
select.sites <- function (normal.table, ad.table, normal.name, ad.name, common.name, percentage){
        #make an index with the common positions
        index1 <- logical(length = nrow(normal.table))
        for (i in seq_len(nrow(normal.table))){
                index1[i] <- normal.table[i, "Position"] %in% ad.table[,"Position"]
        }
        
        #make the uniques to normal.table
        uniq.norm <- normal.table[!index1,]
        row.names(uniq.norm) <- seq_len(nrow(uniq.norm))
        assign(paste0("unique.", normal.name), uniq.norm, .GlobalEnv)
        
        #Do the same for ad.table
        index2 <- logical(length = nrow(ad.table))
        for (i in seq_len(nrow(ad.table))){
                index2[i] <- ad.table[i, "Position"] %in% normal.table[,"Position"]
        }
        
        #make the uniques to normal.table
        uniq.ad <- ad.table[!index2,]
        row.names(uniq.ad) <- seq_len(nrow(uniq.ad))
        assign(paste0("unique.", ad.name), uniq.ad, .GlobalEnv)
        
        
        #Make the table with the common positions
        common <- normal.table[index1,]
        names(common)[ncol(common)] <- normal.name
        common[,ad.name] <- NA
        
        for (i in seq_len(nrow(common))){
                common[i,ad.name] <- ad.table[which(ad.table[,"Position"] == 
                                                            common[i, "Position"]), ncol(ad.table)]
        }
        
        #Insert a final column with a logic value that tests whether
        #the two frequencies differ for a certain percentage
        perc <- paste0(as.character(percentage*100), "%")
        common[,paste0(perc, " difference")] <- NA
        for (i in seq_len(nrow(common))){
                common[i,ncol(common)] <- abs(common[i,ncol(common) - 1] -
                        common[i,ncol(common) - 2]) >= percentage
        }
        
        row.names(common) <- seq_len(nrow(common))
        assign(paste0("common.", common.name), common, .GlobalEnv)
}


#Select UTR3
select.sites(adar.normal[which(adar.normal[,"Func.refGene"] == "UTR3"),],
             adar.ad[which(adar.ad[,"Func.refGene"] == "UTR3"),],
             "adar.normal.UTR3",
             "adar.ad.UTR3",
             "adar.UTR3",
             0.2)

#select exonic
select.sites(adar.normal[which(adar.normal[,"Func.refGene"] == "exonic"),],
             adar.ad[which(adar.ad[,"Func.refGene"] == "exonic"),],
             "adar.normal.exonic",
             "adar.ad.exonic",
             "adar.exonic",
             0.2)

#APOBEC Select UTR3
select.sites(apobec.normal[which(apobec.normal[,"Func.refGene"] == "UTR3"),],
             apobec.ad[which(apobec.ad[,"Func.refGene"] == "UTR3"),],
             "apobec.normal.UTR3",
             "apobec.ad.UTR3",
             "apobec.UTR3",
             0.2)

#APOBEC select exonic
select.sites(apobec.normal[which(apobec.normal[,"Func.refGene"] == "exonic"),],
             apobec.ad[which(apobec.ad[,"Func.refGene"] == "exonic"),],
             "apobec.normal.exonic",
             "apobec.ad.exonic",
             "apobec.exonic",
             0.2)
 
#Copy the results from the gene expression analysis and load them
results.GE <- read.table("input_files/gene expression/results.GE", header = T)

#You need to split double genes so that the add.change function can work
#Function to split double genes in the ref.Gene field in seperate rows
split.genes <- function(table) {
        #make an index with the rows that have double genes
        index <- grep(",", table$Gene.refGene, fixed = T)
        #if there are no double genes, then return the table
        if (length(index) == 0) {table}
        #else, build two tables and then combine them
        else {
                table2 <- table[-c(index),]
                table3 <- table[index,]
                #build a table with twice as many rows to put the double genes
                double <- table3[rep(seq_len(nrow(table3)), each=2),]
                double$Gene.refGene <- as.character(double$Gene.refGene)
                for (i in seq_len(nrow(table3))) {
                        data.row1 <- i*2 -1
                        data.row2 <- i*2
                        gene1 <- strsplit(as.character(table3$Gene.refGene[i]),
                                          ",", fixed = T)[[1]][1]
                        gene2 <- strsplit(as.character(table3$Gene.refGene[i]),
                                          ",", fixed = T)[[1]][2]
                        
                        double[data.row1,"Gene.refGene"] <- gene1
                        double[data.row2,"Gene.refGene"] <- gene2
                }
                #combine the two tables
                final <- rbind(table2,double)
                row.names(final) <- seq_len(nrow(final))
                final
        }
}

common.adar.exonic <- split.genes(common.adar.exonic)
common.adar.UTR3 <- split.genes(common.adar.UTR3)
unique.adar.ad.exonic <- split.genes(unique.adar.ad.exonic)
unique.adar.ad.UTR3 <- split.genes(unique.adar.ad.UTR3)
unique.adar.normal.exonic <- split.genes(unique.adar.normal.exonic)
unique.adar.normal.UTR3 <- split.genes(unique.adar.normal.UTR3)

common.apobec.exonic <- split.genes(common.apobec.exonic)
common.apobec.UTR3 <- split.genes(common.apobec.UTR3)
unique.apobec.ad.exonic <- split.genes(unique.apobec.ad.exonic)
unique.apobec.ad.UTR3 <- split.genes(unique.apobec.ad.UTR3)
unique.apobec.normal.exonic <- split.genes(unique.apobec.normal.exonic)
unique.apobec.normal.UTR3 <- split.genes(unique.apobec.normal.UTR3)


#Function to add a column to the tables that will contain the log2fold change.
#symbol.col is the column of the results table that contains the gene symbols.
#gene.col is the column of the table that contains the gene symbols
add.change <- function (table, results, gene.col = "Gene.refGene") {
        library("AnnotationDbi")  #Base package
        library("org.Hs.eg.db")  #Human
        table[,"log2FoldChange"] <- NA
        table[,"significant change"] <- NA
        table[,gene.col] <- as.character(table[,gene.col])
        for (i in seq_len(nrow(table))) {                
                gene <- function(x){
                        tryCatch(mapIds(org.Hs.eg.db,
                                                keys=x,
                                                column="ENSEMBL",
                                                keytype="SYMBOL",
                                                multiVals="first"), error = function(e) {NA})
                }
                
                if (gene(table[i, gene.col]) %in% row.names(results)) {
                        table[i, "log2FoldChange"] <-
                                results[which(row.names(results) == gene(table[i, gene.col])), "log2FoldChange"]
                        
                        if (!is.na(results[which(row.names(results) == gene(table[i, gene.col])), "padj"])) {
                                if (results[which(row.names(results) == gene(table[i, gene.col])), "padj"] <= 0.05) {
                                        table[i, "significant change"] <- TRUE
                                }
                                else {
                                        table[i, "significant change"] <- FALSE
                                }
                        }
                        else {
                                table[i, "significant change"] <- FALSE
                        }
                }
                else {
                        print("NAs returned")
                }
        }
        table
}


common.adar.exonic <- add.change(common.adar.exonic, results.GE)
common.adar.UTR3 <- add.change(common.adar.UTR3, results.GE)
unique.adar.ad.exonic <- add.change(unique.adar.ad.exonic, results.GE)
unique.adar.ad.UTR3 <- add.change(unique.adar.ad.UTR3, results.GE)
unique.adar.normal.exonic <- add.change(unique.adar.normal.exonic, results.GE)
unique.adar.normal.UTR3 <- add.change(unique.adar.normal.UTR3, results.GE)

common.apobec.exonic <- add.change(common.apobec.exonic, results.GE)
common.apobec.UTR3 <- add.change(common.apobec.UTR3, results.GE)
unique.apobec.ad.exonic <- add.change(unique.apobec.ad.exonic, results.GE)
unique.apobec.ad.UTR3 <- add.change(unique.apobec.ad.UTR3, results.GE)
unique.apobec.normal.exonic <- add.change(unique.apobec.normal.exonic, results.GE)
unique.apobec.normal.UTR3 <- add.change(unique.apobec.normal.UTR3, results.GE)

#Save the tables containing only UTR3 positions to be used in the pathway analysis
save(common.apobec.UTR3, common.adar.UTR3, unique.apobec.normal.UTR3,
     unique.adar.ad.UTR3, unique.apobec.ad.UTR3, unique.adar.normal.UTR3,
     file = "tables_for_pathways")
     
The pathway analysis (performed entirely in R):

To perform the pathway analysis the pathview package was used (http://pathview.r-forge.r-project.org/).


#Copy and load the file with the gene expression results from the expression analysis
sig.results.GE <- read.xlsx("input_files/sig.results.GE.xlsx", sheetIndex = 1)

#Copy and load the tables of the genes (only UTR3) from the diff.editing analysis
load("input_files/tables_for_pathways")

#Merge the tables into one table
#change the names of the frequency columns for the unique
names(unique.adar.ad.UTR3)[11] <- "ad.UTR3"
names(unique.adar.normal.UTR3)[11] <- "normal.UTR3"
names(unique.apobec.ad.UTR3)[11] <- "ad.UTR3"
names(unique.apobec.normal.UTR3)[11] <- "normal.UTR3"
names(common.adar.UTR3)[c(11,12)] <- c("normal.UTR3", "ad.UTR3")
names(common.apobec.UTR3)[c(11,12)] <- c("normal.UTR3", "ad.UTR3")
#add new column for frequencies
unique.adar.ad.UTR3$normal.UTR3 <- NA
unique.apobec.ad.UTR3$normal.UTR3 <- NA
unique.adar.normal.UTR3$ad.UTR3 <- NA
unique.apobec.normal.UTR3$ad.UTR3 <- NA
#reorder the columns
unique.adar.ad.UTR3 <- unique.adar.ad.UTR3[c(1:10,14,11,12,13)]
unique.apobec.ad.UTR3 <- unique.apobec.ad.UTR3[c(1:10,14,11,12,13)]
unique.adar.normal.UTR3 <- unique.adar.normal.UTR3[c(1:11,14,12,13)]
unique.apobec.normal.UTR3 <- unique.apobec.normal.UTR3[c(1:11,14,12,13)]
#remove the 20% change column from the common
common.adar.UTR3 <- common.adar.UTR3[,-13]
common.apobec.UTR3 <- common.apobec.UTR3[,-13]
#Add a new column for the enzyme
unique.adar.ad.UTR3$enzyme <- "adar"
unique.apobec.ad.UTR3$enzyme <- "apobec"
unique.adar.normal.UTR3$enzyme <- "adar"
unique.apobec.normal.UTR3$enzyme <- "apobec"
common.adar.UTR3$enzyme <- "adar"
common.apobec.UTR3$enzyme <- "apobec"
#Add a new column in the tables that will have a value of:
#0 for the commons table
#-1 for the AD table
#1 for the Normal table
unique.adar.ad.UTR3$colcode <- -1
unique.apobec.ad.UTR3$colcode <- -1
unique.adar.normal.UTR3$colcode <- 1
unique.apobec.normal.UTR3$colcode <- 1
common.adar.UTR3$colcode <- 0
common.apobec.UTR3$colcode <- 0
#Bind the table
all <- rbind(common.apobec.UTR3, common.adar.UTR3,
             unique.apobec.normal.UTR3, unique.adar.normal.UTR3,
             unique.apobec.ad.UTR3, unique.adar.ad.UTR3)
all <- all[,-16]
all$colcode1 <- c(common.apobec.UTR3$colcode, common.adar.UTR3$colcode,
                  rep(NA, times = 5113))
all$colcode2 <- c(rep(NA, times = 853),
                  unique.apobec.normal.UTR3$colcode, unique.adar.normal.UTR3$colcode,
                  rep(NA, times = 3438))
all$colcode3 <- c(rep(NA, times = 2528),unique.apobec.ad.UTR3$colcode, unique.adar.ad.UTR3$colcode)
     
names.all <- as.character(all$Gene.refGene)
mat.all <- as.matrix(all[,c(16,17,18)])
row.names(mat.all) <- names.all     

################Visualization

####LOOP for all the pathways
ids <- c("05014", "00190", "03013",
         "03050", "04064", "04120", "04141",
         "04142", "04210", "04721", "04724",
         "05010")
suffixes <- c("ALS", "Oxidative phosphorylation",
              "RNA transport", "Proteasome", "NFKB",
              "ubiquitin mediated proteolysis",
              "Protein processing in ER", "Lysosome",
              "Apoptosis", "Synaptic vesicle cycle",
              "Glutamatergic synapse", "Alzheimer's Disease")

library("pathview")

for (i in seq_along(ids)){
        pv.out <- pathview(gene.data = mat.all[,1:3], pathway.id = ids[i], species = "hsa",
                           out.suffix = suffixes[i], kegg.native = T, gene.idtype = "SYMBOL",
                           res=600, kegg.dir = "./kegg",
                           low = list(gene = "red", cpd = "blue"),
                           mid = list(gene = "#00FFFF", cpd = "gray"),
                           high = list(gene = "green", cpd = "yellow"))
}
